/************************
 //  \file   ts_io.h
 //  \brief
 // 
 //  \author czhou
 //  \date   19 juin 2015 
 ***********************/
#ifndef TS_IO_H_
#define TS_IO_H_

#include "ts_define.h"
#include "ts_point.h"
#include "ts_vertex.h"
#include "ts_segment.h"
#include "ts_triangle.h"
#include "ts_edge.h"
// vtk include
#include <vtkSmartPointer.h>
#include <vtkTriangle.h>
#include <vtkVoxel.h>
#include <vtkCellArray.h>
#include <vtkPolyData.h>
#include <vtkPolyDataMapper.h>
#include <vtkActor.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderer.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkUnstructuredGrid.h>
#include <vtkDataSetMapper.h>
#include <vtkTransform.h>
#include <vtkAxesActor.h>
//
namespace LarusTS {

template<class BOX>
void output_vtk(String fn, const List<BOX>& lbn) {
	FILE *data;
	data = fopen(fn.c_str(), "w");
	if (data == NULL) {
		std::cerr << "!> Open file error! " << fn << " \n";
		exit(-1);
	}
	uInt num_b = lbn.size();
	uInt NUM_VERTEXES = BOX::Dim == 3 ? 8 : 4;
	fprintf(data, "# vtk DataFile Version 3.0\n");
	fprintf(data, "Gird output\n");
	fprintf(data, "ASCII\n");
	fprintf(data, "DATASET UNSTRUCTURED_GRID\n");
	fprintf(data, "POINTS %d float\n", NUM_VERTEXES * num_b);
	for (auto iter = lbn.begin(); iter != lbn.end(); ++iter) {
		for (uInt i = 0; i < NUM_VERTEXES; i++) {
			fprintf(data, "%f %f %f \n",
					(*iter).get_point(_ORDER_VTK[i][0], _ORDER_VTK[i][1],
							_ORDER_VTK[i][2]).x(),
					(*iter).get_point(_ORDER_VTK[i][0], _ORDER_VTK[i][1],
							_ORDER_VTK[i][2]).y(),
					BOX::Dim == 3 ?
							(*iter).get_point(_ORDER_VTK[i][0],
									_ORDER_VTK[i][1], _ORDER_VTK[i][2]).z() :
							0);
		}
	}
	fprintf(data, "\n");
	fprintf(data, "CELLS %d %d \n", num_b, num_b * (NUM_VERTEXES + 1));
	for (int i = 0; i < NUM_VERTEXES * num_b; ++i) {
		if (i % NUM_VERTEXES == 0) {
			fprintf(data, "%d ", NUM_VERTEXES);
		}
		fprintf(data, "%d ", i);
		if (i % NUM_VERTEXES == 7) {
			fprintf(data, "\n");
		}
	}
	fprintf(data, "\n\n");
	fprintf(data, "CELL_TYPES %d\n", num_b);
	for (int i = 0; i < num_b; ++i) {
		fprintf(data, "%d \n", BOX::Dim == 3 ? 11 : 8);
	}
	//VTK_VOXEL (=11)  -- 3D
	//VTK_PIXEL (=8)   -- 2D
	fclose(data);
}

template<class BOX>
void output_vtk(String fn, const List<BOX*>& lbn) {
	FILE *data;
	data = fopen(fn.c_str(), "w");
	if (data == NULL) {
		std::cerr << "!> Open file error! " << fn << " \n";
		exit(-1);
	}
	uInt num_b = lbn.size();
	uInt NUM_VERTEXES = BOX::Dim == 3 ? 8 : 4;
	fprintf(data, "# vtk DataFile Version 3.0\n");
	fprintf(data, "Gird output\n");
	fprintf(data, "ASCII\n");
	fprintf(data, "DATASET UNSTRUCTURED_GRID\n");
	fprintf(data, "POINTS %d float\n", NUM_VERTEXES * num_b);
	for (auto iter = lbn.begin(); iter != lbn.end(); ++iter) {
		for (uInt i = 0; i < NUM_VERTEXES; i++) {
			fprintf(data, "%f %f %f \n",
					(*iter)->get_point(_ORDER_VTK[i][0], _ORDER_VTK[i][1],
							_ORDER_VTK[i][2]).x(),
					(*iter)->get_point(_ORDER_VTK[i][0], _ORDER_VTK[i][1],
							_ORDER_VTK[i][2]).y(),
					BOX::Dim == 3 ?
							(*iter)->get_point(_ORDER_VTK[i][0],
									_ORDER_VTK[i][1], _ORDER_VTK[i][2]).z() :
							0);
		}
	}
	fprintf(data, "\n");
	fprintf(data, "CELLS %d %d \n", num_b, num_b * (NUM_VERTEXES + 1));
	for (int i = 0; i < NUM_VERTEXES * num_b; ++i) {
		if (i % NUM_VERTEXES == 0) {
			fprintf(data, "%d ", NUM_VERTEXES);
		}
		fprintf(data, "%d ", i);
		if (i % NUM_VERTEXES == 7) {
			fprintf(data, "\n");
		}
	}
	fprintf(data, "\n\n");
	fprintf(data, "CELL_TYPES %d\n", num_b);
	for (int i = 0; i < num_b; ++i) {
		fprintf(data, "%d \n", BOX::Dim == 3 ? 11 : 8);
	}
	//VTK_VOXEL (=11)  -- 3D
	//VTK_PIXEL (=8)   -- 2D
	fclose(data);
}

template<class VALUE>
void output_vtk(const String& fn,  //
		VALUE V0[3], VALUE V1[3], VALUE V2[3] //Triangle V
		) {
	FILE* fptr = fopen(fn.c_str(), "w"); //write
	if (fptr == NULL) {
		std::cerr << "!> Open file error! " << fn << " \n";
		exit(-1);
	}
	fprintf(fptr, "# vtk DataFile Version 2.0\n"
			"Generated by LarusTS\n"
			"ASCII\n"
			"DATASET POLYDATA\n"
			"POINTS %d float\n", 3);

	fprintf(fptr, "%f %f %f \n", V0[0], V0[1], V0[2]);
	fprintf(fptr, "%f %f %f \n", V1[0], V1[1], V1[2]);
	fprintf(fptr, "%f %f %f \n", V2[0], V2[1], V2[2]);

	fprintf(fptr, "POLYGONS %d %d\n", 1, 4);
	fprintf(fptr, "3 %u %u %u\n", 0, 1, 2);
	fclose(fptr);
}

template<class VALUE>
void output_vtk(const String& fn,  //
		VALUE V0[3], VALUE V1[3]  //Triangle V
		) {
	FILE* fptr = fopen(fn.c_str(), "w"); //write
	if (fptr == NULL) {
		std::cerr << "!> Open file error! " << fn << " \n";
		exit(-1);
	}
	fprintf(fptr, "# vtk DataFile Version 2.0\n"
			"Generated by LarusTS\n"
			"ASCII\n"
			"DATASET UNSTRUCTURED_GRID\n"
			"POINTS %d float\n", 2);

	fprintf(fptr, "%f %f %f \n", V0[0], V0[1], V0[2]);
	fprintf(fptr, "%f %f %f \n", V1[0], V1[1], V1[2]);

	fprintf(fptr, "CELLS %d %d\n", 1, 3);
	fprintf(fptr, "2 %u %u \n", 0, 1);
	fprintf(fptr, "CELL_TYPES %d \n", 1);
	fprintf(fptr, "3\n");

	fclose(fptr);
}

/*
 * vtk show
 */
int vtk_show_actor(vtkSmartPointer<vtkProp> actor[], vtkIdType len) {
	//
	//actor->GetProperty()->SetRepresentationToWireframe();
	// Create a renderer, render window and interactor
	vtkSmartPointer<vtkRenderer> renderer = vtkSmartPointer<vtkRenderer>::New();
	vtkSmartPointer<vtkRenderWindow> renderWindow = vtkSmartPointer<
			vtkRenderWindow>::New();
	renderWindow->AddRenderer(renderer);
	vtkSmartPointer<vtkRenderWindowInteractor> renderWindowInteractor =
			vtkSmartPointer<vtkRenderWindowInteractor>::New();
	renderWindowInteractor->SetRenderWindow(renderWindow);

	// Add the actors to the scene
	for (vtkIdType i = 0; i < len; ++i) {
		renderer->AddActor(actor[i]);
	}
	renderer->SetBackground(.1, .2, .3); // Background color dark blue

	// Render and interact
	renderWindow->Render();
	renderWindowInteractor->Start();

	return EXIT_SUCCESS;
}

int vtk_show_actor(const std::list<vtkSmartPointer<vtkProp> >& list_actor) {
	//
	//actor->GetProperty()->SetRepresentationToWireframe();
	// Create a renderer, render window and interactor
	vtkSmartPointer<vtkRenderer> renderer = vtkSmartPointer<vtkRenderer>::New();
	vtkSmartPointer<vtkRenderWindow> renderWindow = vtkSmartPointer<
			vtkRenderWindow>::New();
	renderWindow->AddRenderer(renderer);
	vtkSmartPointer<vtkRenderWindowInteractor> renderWindowInteractor =
			vtkSmartPointer<vtkRenderWindowInteractor>::New();
	renderWindowInteractor->SetRenderWindow(renderWindow);

	// Add the actors to the scene
	for (typename std::list<vtkSmartPointer<vtkProp> >::const_iterator iter =
			list_actor.begin(); iter != list_actor.end(); ++iter) {
		renderer->AddActor(*iter);
	}
	renderer->SetBackground(.1, .2, .3); // Background color dark blue

	// Render and interact
	renderWindow->Render();
	renderWindowInteractor->Start();

	return EXIT_SUCCESS;
}

static const Location vtk_VOXEL[8][3] = { //
		//         x    y    z
				{ _M, _M, _M }, //
				{ _P, _M, _M }, //
				{ _M, _P, _M }, //
				{ _P, _P, _M }, //
				{ _M, _M, _P }, //
				{ _P, _M, _P }, //
				{ _M, _P, _P }, //
				{ _P, _P, _P }, //
		};

template<typename BOX>
void _vtkUnstructuredGrid_add_node(
		const BOX& box, //
		vtkSmartPointer<vtkPoints> points,
		vtkSmartPointer<vtkUnstructuredGrid> ugrid) {
	//ASSERT(box != nullptr);
	typedef typename BOX::value_type vt;
	typedef BOX node_t;
	vtkIdType n = points->GetNumberOfPoints();

	for (size_t i = 0; i < box.NumVertexes; ++i) {
		vt x = box.get(vtk_VOXEL[i][0], _X);
		vt y = (node_t::Dim >= 2) ? box.get(vtk_VOXEL[i][1], _Y) : 0.0;
		vt z = (node_t::Dim == 3) ? box.get(vtk_VOXEL[i][2], _Z) : 0.0;
		points->InsertNextPoint(x, y, z);
	}

	vtkSmartPointer<vtkVoxel> voxel = vtkSmartPointer<vtkVoxel>::New();
	// append idx
	for (size_t i = 0; i < box.NumVertexes; ++i) {
		voxel->GetPointIds()->SetId(i, n + i);
	}
	// Insert to Unstrcture Grid
	ugrid->InsertNextCell(voxel->GetCellType(), voxel->GetPointIds());
}

template<class TYPE, st DIM>
void _vtkPolyData_add_surface(
		const Surface<TYPE, DIM>& sur, //
		vtkSmartPointer<vtkPoints> points,
		vtkSmartPointer<vtkCellArray> cellarray) {
	//ASSERT(box != nullptr);
	//typedef typename Surface<TYPE, DIM>::value_type vt;

	vtkIdType n = points->GetNumberOfPoints();
	for (auto iter = sur.faces.begin(); iter != sur.faces.end(); ++iter) {
		typename Surface<TYPE, DIM>::pFac pf = (*iter);
		points->InsertNextPoint(pf->get_vertex1()->x(), pf->get_vertex1()->y(),
				pf->get_vertex1()->z());
		points->InsertNextPoint(pf->get_vertex2()->x(), pf->get_vertex2()->y(),
				pf->get_vertex2()->z());
		points->InsertNextPoint(pf->get_vertex3()->x(), pf->get_vertex3()->y(),
				pf->get_vertex3()->z());
		vtkSmartPointer<vtkTriangle> tri = vtkSmartPointer<vtkTriangle>::New();
		//
		for (size_t i = 0; i < 3; ++i) {
			tri->GetPointIds()->SetId(i, n + i);
		}
		cellarray->InsertNextCell(tri);
		n = n + 3;
	}
}

template<class TYPE, st DIM>
vtkSmartPointer<vtkActor> vtk_new_actor_surface(const Surface<TYPE, DIM>& sur) {
	vtkSmartPointer<vtkPoints> points = vtkSmartPointer<vtkPoints>::New();
	vtkSmartPointer<vtkCellArray> cellarray =
			vtkSmartPointer<vtkCellArray>::New();
	// Add the geometry and topology to the unstructure grid
	_vtkPolyData_add_surface(sur, points, cellarray);
	vtkSmartPointer<vtkPolyData> trianglePolyData =
			vtkSmartPointer<vtkPolyData>::New();

	// Add the geometry and topology to the polydata
	trianglePolyData->SetPoints(points);
	trianglePolyData->SetPolys(cellarray);

	// Create a mapper and actor
	vtkSmartPointer<vtkDataSetMapper> mapper =
			vtkSmartPointer<vtkDataSetMapper>::New();
#if VTK_MAJOR_VERSION <= 5
	mapper->SetInput(ugrid);
#else
	mapper->SetInputData(trianglePolyData);
#endif
	vtkSmartPointer<vtkActor> actor = vtkSmartPointer<vtkActor>::New();
	actor->SetMapper(mapper);

	return actor;
}

template<typename BOX>
vtkSmartPointer<vtkActor> vtk_new_actor(const BOX& box) {
	//ASSERT(box != nullptr);
	vtkSmartPointer<vtkPoints> points = vtkSmartPointer<vtkPoints>::New();
	vtkSmartPointer<vtkUnstructuredGrid> ugrid = vtkSmartPointer<
			vtkUnstructuredGrid>::New();
	// Add the geometry and topology to the unstructure grid
	_vtkUnstructuredGrid_add_node(box, points, ugrid);

	ugrid->SetPoints(points);

	// Create a mapper and actor
	vtkSmartPointer<vtkDataSetMapper> mapper =
			vtkSmartPointer<vtkDataSetMapper>::New();
#if VTK_MAJOR_VERSION <= 5
	mapper->SetInput(ugrid);
#else
	mapper->SetInputData(ugrid);
#endif
	vtkSmartPointer<vtkActor> actor = vtkSmartPointer<vtkActor>::New();
	actor->SetMapper(mapper);

	return actor;

}

vtkSmartPointer<vtkAxesActor> vtk_new_actor_axes(double x, double y, double z) {
	vtkSmartPointer<vtkTransform> transform =
			vtkSmartPointer<vtkTransform>::New();
	transform->Translate(x, y, z);

	vtkSmartPointer<vtkAxesActor> axes = vtkSmartPointer<vtkAxesActor>::New();

	// The axes are positioned with a user transform
	axes->SetUserTransform(transform);

	return axes;
}

template<typename BOX>
vtkSmartPointer<vtkActor> vtk_new_actor(const List<BOX*>& lbn) {
	typedef BOX* pnode;
	vtkSmartPointer<vtkPoints> points = vtkSmartPointer<vtkPoints>::New();
	vtkSmartPointer<vtkUnstructuredGrid> ugrid = vtkSmartPointer<
			vtkUnstructuredGrid>::New();
	//
	for (pnode pn : lbn) {
		if (pn != nullptr) {
			_vtkUnstructuredGrid_add_node((*pn), points, ugrid);
		}
	}

	ugrid->SetPoints(points);

	// Create a mapper and actor
	vtkSmartPointer<vtkDataSetMapper> mapper =
			vtkSmartPointer<vtkDataSetMapper>::New();
#if VTK_MAJOR_VERSION <= 5
	mapper->SetInput(ugrid);
#else
	mapper->SetInputData(ugrid);
#endif
	vtkSmartPointer<vtkActor> actor = vtkSmartPointer<vtkActor>::New();
	actor->SetMapper(mapper);
	actor->GetProperty()->SetRepresentationToWireframe();
	return actor;
}

/*
 * high level =============================================
 */
template<typename BOX>
int vtk_show(BBTree<BOX> &tree, int height = 0) {
	typedef BOX* pnode;

	vtkSmartPointer<vtkPoints> points = vtkSmartPointer<vtkPoints>::New();
	vtkSmartPointer<vtkUnstructuredGrid> ugrid = vtkSmartPointer<
			vtkUnstructuredGrid>::New();
	//
	int count = 0;
	for (typename BBTree<BOX>::iterator iter = tree.begin(); iter != tree.end();
			++iter) {
		typename BBTree<BOX>::Node pn = (*iter);
		BOX box = pn.box;
		if (pn.height() == height) {
			_vtkUnstructuredGrid_add_node(box, points, ugrid);
		}
		count++;
	}
	//cout<<" size "<<points->GetNumberOfPoints()<<endl;
	cout << " size " << ugrid->GetNumberOfCells() << endl;
	cout << " coutn " << count << endl;

	ugrid->SetPoints(points);

	// Create a mapper and actor
	vtkSmartPointer<vtkDataSetMapper> mapper =
			vtkSmartPointer<vtkDataSetMapper>::New();
#if VTK_MAJOR_VERSION <= 5
	mapper->SetInput(ugrid);
#else
	mapper->SetInputData(ugrid);
#endif
	vtkSmartPointer<vtkActor> actor = vtkSmartPointer<vtkActor>::New();
	actor->SetMapper(mapper);
	actor->GetProperty()->SetRepresentationToWireframe();

	vtkSmartPointer<vtkRenderer> renderer = vtkSmartPointer<vtkRenderer>::New();
	vtkSmartPointer<vtkRenderWindow> renderWindow = vtkSmartPointer<
			vtkRenderWindow>::New();
	renderWindow->AddRenderer(renderer);
	vtkSmartPointer<vtkRenderWindowInteractor> renderWindowInteractor =
			vtkSmartPointer<vtkRenderWindowInteractor>::New();
	renderWindowInteractor->SetRenderWindow(renderWindow);

	// Add the actors to the scene
	renderer->AddActor(actor);
	vtkSmartPointer<vtkAxesActor> axe_actor = vtk_new_actor_axes(0, 0, 0);
	renderer->AddActor(axe_actor);
	renderer->SetBackground(.1, .2, .3); // Background color dark blue

	// Render and interact
	renderWindow->Render();
	renderWindowInteractor->Start();

	return EXIT_SUCCESS;
}

}

#endif /* TS_IO_H_ */
